---
description: "Stack-agnostic end-to-end workflow with Spec Kit and GitHub Issues"
globs: ["**/*"]
alwaysApply: true
---

# Workflow Overview

## 1. Triage\n- If this is the first ticket in a new repo, run `npm run bootstrap` to seed Spec Kit templates.\n- Confirm objective, scope, constraints, and success criteria with the requester.
- Identify unknowns and research needs; capture them in the issue/spec.
- Create or link the driving GitHub Issue (or Spec Kit task) **before** writing code.
- Decide whether Spec Kit automation or a lightweight GitHub workflow is appropriate.

### Research & Context Gathering
- Use DocFork MCP and web search for standards or prior art.
- Use GitHub MCP to inspect related issues/PRs.
- Run Playwright MCP for quick UI/accessibility snapshots when visuals are involved.

## 2. Plan\n- Execute `npm run new-feature -- --title "<ticket title>"` to scaffold Spec Kit docs before planning.\n- Spec Kit available: run `/specify`, `/clarify`, `/plan`, `/tasks`.
- GitHub workflow: write a short plan (3–6 bullets) with risks, data/model considerations, and verification strategy.
- Call out dependencies, rollout steps, and fallback strategies.

## 3. Build
- Work from the plan/tasks; keep changes incremental and reversible.
- Automate git operations with GitHub MCP or your preferred script.
- Update documentation, env files, and diagrams when the change affects them.
- Log any deviations from the plan in the ticket/spec.

### MCP Checkpoints
- UI changes ? Playwright MCP (screenshots, axe/Lighthouse).
- Data changes ? Supabase MCP (schema diff, logs, advisors).
- Research-heavy tasks ? DocFork MCP summary linked in the ticket.

## 4. Verify
- Run `npm run verify` (or `node scripts/verify-all`) to execute all scripted checks that exist.
- Add manual checks for scenarios not covered by automation; record evidence.
- If no automated scripts exist yet, outline which checks a future version should include.

### CI Expectations
- GitHub Actions (`.github/workflows/ci.yml`) runs the preflight script and best-effort verification.
- Extend or replace the workflow after your stack is generated so that lint/test/build jobs appear here.

## 5. Close the Loop
- Update the issue/spec with summary, validation results, and follow-up tasks.
- Ensure GitHub Issue status and labels reflect completion.
- Merge via PR with risk note, backout plan, and evidence.
- Capture lessons learned in the process improvement rule if applicable.

---

# Ticket Template (Lightweight)
```
## Goal
What outcome are we aiming for?

## Plan
- Step 1
- Step 2
- Step 3

## Risks & Unknowns
- Item 1

## Validation
- Automated: ...
- Manual: ...

## Follow-up
- [ ] TODO with owner
```

---

# Automation Hooks

- Add stack-specific commands to `package.json` once the project is generated.
- Extend `scripts/verify-all` with custom detection logic if needed.
- Update `.github/workflows/ci.yml` to run the right jobs (pnpm, npm, cargo, etc.).
- Keep `.cursor/mcp.json` in sync with the tools you rely on; remove unused servers to reduce noise.

---

# Exception Handling

When automation is unavailable or partially configured:
1. Document the gap in the issue/spec.
2. Provide manual steps for verification.
3. Create a follow-up task to automate or script it later.

---

# Done Means Done

A ticket is complete when the plan is executed, code/tests/docs merged, issues closed, and follow-up tasks logged. Anything less is “in progress.”