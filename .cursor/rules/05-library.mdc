---
description: "Code Library - Conventions, Snippets, and Reusable Patterns"
globs: ["**/*"]
alwaysApply: true
---

# Code Library & Conventions

## General Principles

### 1. Scaffold-Ready Design
- **Universal Compatibility**: All conventions work with any project type (React, Vue, Node.js, etc.)
- **Progressive Enhancement**: Start simple, add complexity as needed
- **Clear Documentation**: Every convention is documented with examples
- **Tool Agnostic**: Work with any package manager, build tool, or framework

### 2. Consistency First
- **Uniform Patterns**: Use consistent patterns across all files and directories
- **Predictable Structure**: Developers should know where to find things
- **Clear Naming**: Names should be self-documenting
- **Standard Formats**: Use standard file formats and extensions

## File and Directory Naming

### Directory Structure
```
project-root/
‚îú‚îÄ‚îÄ .cursor/                 # Cursor AI configuration
‚îú‚îÄ‚îÄ .github/                 # GitHub workflows and templates
‚îú‚îÄ‚îÄ docs/                    # Project documentation
‚îú‚îÄ‚îÄ scripts/                 # Build and utility scripts
‚îú‚îÄ‚îÄ frontend/                # Frontend application (if applicable)
‚îú‚îÄ‚îÄ backend/                 # Backend application (if applicable)
‚îú‚îÄ‚îÄ shared/                  # Shared code and utilities
‚îú‚îÄ‚îÄ tests/                   # Test files and configurations
‚îú‚îÄ‚îÄ artifacts/               # Build outputs and logs
‚îî‚îÄ‚îÄ config/                  # Configuration files
```

### Naming Conventions

#### Files
- **kebab-case**: Use kebab-case for all file names
  - ‚úÖ `user-profile.component.tsx`
  - ‚úÖ `api-client.service.ts`
  - ‚ùå `UserProfile.component.tsx`
  - ‚ùå `api_client.service.ts`

#### Directories
- **kebab-case**: Use kebab-case for directory names
  - ‚úÖ `user-management/`
  - ‚úÖ `api-services/`
  - ‚ùå `UserManagement/`
  - ‚ùå `api_services/`

#### Configuration Files
- **dot-prefixed**: Use dot-prefixed names for configuration files
  - ‚úÖ `.eslintrc.js`
  - ‚úÖ `.env.example`
  - ‚úÖ `.gitignore`
  - ‚ùå `eslintrc.js`
  - ‚ùå `env.example`

#### Test Files
- **suffix-based**: Use consistent suffixes for test files
  - ‚úÖ `component.test.tsx`
  - ‚úÖ `service.spec.ts`
  - ‚úÖ `utils.test.js`
  - ‚ùå `component.testing.tsx`
  - ‚ùå `service.test.ts`

## Code Style

### TypeScript/JavaScript

#### Variable Naming
```typescript
// ‚úÖ Good
const userProfile = getUserProfile();
const isAuthenticated = checkAuthStatus();
const API_BASE_URL = 'https://api.example.com';

// ‚ùå Bad
const user_profile = getUserProfile();
const IsAuthenticated = checkAuthStatus();
const apiBaseUrl = 'https://api.example.com';
```

#### Function Naming
```typescript
// ‚úÖ Good
function calculateTotalPrice(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

function isValidEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// ‚ùå Bad
function calcTotal(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

function checkEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}
```

### React Components

#### Component Structure
```typescript
// ‚úÖ Good
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

export function UserProfile({ userId, onUpdate }: UserProfileProps) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;
  
  return (
    <div className="user-profile">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

### CSS/Styling

#### Class Naming (BEM Methodology)
```css
/* ‚úÖ Good */
.user-profile {
  padding: 1rem;
  border: 1px solid #ccc;
}

.user-profile__header {
  font-size: 1.5rem;
  font-weight: bold;
}

.user-profile__content {
  margin-top: 1rem;
}

.user-profile--highlighted {
  background-color: #f0f0f0;
}
```

#### CSS Custom Properties
```css
/* ‚úÖ Good */
:root {
  --color-primary: #007bff;
  --color-secondary: #6c757d;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 2rem;
  --border-radius: 4px;
  --font-size-base: 1rem;
  --font-size-lg: 1.25rem;
  --font-size-xl: 1.5rem;
}

.button {
  background-color: var(--color-primary);
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius);
  font-size: var(--font-size-base);
}
```

## Documentation

### JSDoc Comments
```typescript
/**
 * Calculates the total price for a list of items including tax
 * @param items - Array of items to calculate total for
 * @param taxRate - Tax rate as a decimal (e.g., 0.08 for 8%)
 * @returns Total price including tax
 * @throws {Error} When items array is empty
 * @example
 * ```typescript
 * const items = [{ price: 10 }, { price: 20 }];
 * const total = calculateTotalWithTax(items, 0.08);
 * console.log(total); // 32.4
 * ```
 */
function calculateTotalWithTax(items: Item[], taxRate: number): number {
  if (items.length === 0) {
    throw new Error('Items array cannot be empty');
  }
  
  const subtotal = items.reduce((sum, item) => sum + item.price, 0);
  return subtotal * (1 + taxRate);
}
```

## Testing

### Test Structure

#### Unit Tests
```typescript
// ‚úÖ Good
describe('UserService', () => {
  let userService: UserService;
  let mockApiClient: jest.Mocked<ApiClient>;
  
  beforeEach(() => {
    mockApiClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn(),
      delete: jest.fn(),
    };
    userService = new UserService(mockApiClient);
  });
  
  describe('getUserById', () => {
    it('should return user when API call succeeds', async () => {
      // Arrange
      const userId = '123';
      const expectedUser = { id: userId, name: 'John Doe', email: 'john@example.com' };
      mockApiClient.get.mockResolvedValue(expectedUser);
      
      // Act
      const result = await userService.getUserById(userId);
      
      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockApiClient.get).toHaveBeenCalledWith(`/users/${userId}`);
    });
  });
});
```

### Test Naming

#### Good Test Names
```typescript
// ‚úÖ Good
describe('UserService', () => {
  describe('getUserById', () => {
    it('should return user when valid ID is provided', () => {});
    it('should throw error when user is not found', () => {});
    it('should throw error when ID is invalid', () => {});
  });
});
```

## Git Workflow

### Commit Messages

#### Conventional Commits
```bash
# ‚úÖ Good
feat: add user authentication system
fix: resolve memory leak in data processing
docs: update API documentation
style: format code according to ESLint rules
refactor: extract common validation logic
test: add unit tests for user service
chore: update dependencies

# ‚ùå Bad
add auth
fix bug
update docs
format code
refactor
add tests
update deps
```

### Branch Naming

#### Good Branch Names
```bash
# ‚úÖ Good
feature/user-authentication
feature/payment-integration
bugfix/memory-leak-fix
hotfix/security-patch
refactor/api-client
docs/api-documentation
test/user-service-tests
```

## Environment Configuration

### Environment Variables

#### Naming Convention
```bash
# ‚úÖ Good
DATABASE_URL=postgresql://user:pass@localhost:5432/db
API_BASE_URL=https://api.example.com
JWT_SECRET=your-secret-key
REDIS_URL=redis://localhost:6379
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-password
```

## Security

### Input Validation

#### Good Validation
```typescript
// ‚úÖ Good
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  age: z.number().min(18, 'Must be at least 18 years old'),
});

function createUser(userData: unknown): User {
  const validatedData = userSchema.parse(userData);
  return userRepository.create(validatedData);
}
```

### Error Handling

#### Good Error Handling
```typescript
// ‚úÖ Good
async function fetchUser(userId: string): Promise<User> {
  try {
    const response = await apiClient.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    if (error.status === 404) {
      throw new UserNotFoundError(`User with ID ${userId} not found`);
    }
    if (error.status === 403) {
      throw new UnauthorizedError('Insufficient permissions to access user data');
    }
    throw new ApiError('Failed to fetch user data', error);
  }
}
```

## Performance

### Code Optimization

#### Good Performance Practices
```typescript
// ‚úÖ Good
// Use React.memo for expensive components
const ExpensiveComponent = React.memo(({ data }: { data: Data[] }) => {
  const processedData = useMemo(() => {
    return data.map(item => processItem(item));
  }, [data]);
  
  return (
    <div>
      {processedData.map(item => (
        <ItemComponent key={item.id} item={item} />
      ))}
    </div>
  );
});

// Use useCallback for event handlers
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  
  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  return (
    <div>
      <button onClick={handleIncrement}>Increment</button>
      <ExpensiveComponent data={data} />
    </div>
  );
};
```

---

# Reusable Code Snippets

## React Components

### Basic Component Template
```typescript
import React from 'react';

interface ComponentNameProps {
  // Define props here
  title: string;
  onAction?: () => void;
  children?: React.ReactNode;
}

export function ComponentName({ 
  title, 
  onAction, 
  children 
}: ComponentNameProps) {
  return (
    <div className="component-name">
      <h2 className="component-name__title">{title}</h2>
      {children && (
        <div className="component-name__content">
          {children}
        </div>
      )}
      {onAction && (
        <button 
          className="component-name__action"
          onClick={onAction}
        >
          Action
        </button>
      )}
    </div>
  );
}
```

### Hook Template
```typescript
import { useState, useEffect, useCallback } from 'react';

interface UseHookNameOptions {
  // Define options here
  initialValue?: string;
  onSuccess?: (data: any) => void;
  onError?: (error: Error) => void;
}

interface UseHookNameReturn {
  // Define return type here
  data: any;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useHookName({
  initialValue = '',
  onSuccess,
  onError
}: UseHookNameOptions = {}): UseHookNameReturn {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Your data fetching logic here
      const result = await fetch('/api/data');
      const json = await result.json();
      
      setData(json);
      onSuccess?.(json);
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [onSuccess, onError]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    refetch: fetchData
  };
}
```

### Form Component Template
```typescript
import React, { useState, useCallback } from 'react';

interface FormData {
  // Define form fields here
  email: string;
  password: string;
  confirmPassword: string;
}

interface FormComponentProps {
  onSubmit: (data: FormData) => void;
  loading?: boolean;
  error?: string;
}

export function FormComponent({ 
  onSubmit, 
  loading = false, 
  error 
}: FormComponentProps) {
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [validationErrors, setValidationErrors] = useState<Partial<FormData>>({});

  const handleInputChange = useCallback((field: keyof FormData) => (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    setFormData(prev => ({
      ...prev,
      [field]: event.target.value
    }));
    
    // Clear validation error for this field
    if (validationErrors[field]) {
      setValidationErrors(prev => ({
        ...prev,
        [field]: undefined
      }));
    }
  }, [validationErrors]);

  const validateForm = useCallback((): boolean => {
    const errors: Partial<FormData> = {};
    
    if (!formData.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      errors.email = 'Email is invalid';
    }
    
    if (!formData.password) {
      errors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      errors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      errors.confirmPassword = 'Passwords do not match';
    }
    
    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  }, [formData]);

  const handleSubmit = useCallback((event: React.FormEvent) => {
    event.preventDefault();
    
    if (validateForm()) {
      onSubmit(formData);
    }
  }, [formData, validateForm, onSubmit]);

  return (
    <form className="form-component" onSubmit={handleSubmit}>
      {error && (
        <div className="form-component__error">
          {error}
        </div>
      )}
      
      <div className="form-component__field">
        <label htmlFor="email" className="form-component__label">
          Email
        </label>
        <input
          id="email"
          type="email"
          value={formData.email}
          onChange={handleInputChange('email')}
          className="form-component__input"
          disabled={loading}
        />
        {validationErrors.email && (
          <span className="form-component__field-error">
            {validationErrors.email}
          </span>
        )}
      </div>
      
      <div className="form-component__field">
        <label htmlFor="password" className="form-component__label">
          Password
        </label>
        <input
          id="password"
          type="password"
          value={formData.password}
          onChange={handleInputChange('password')}
          className="form-component__input"
          disabled={loading}
        />
        {validationErrors.password && (
          <span className="form-component__field-error">
            {validationErrors.password}
          </span>
        )}
      </div>
      
      <div className="form-component__field">
        <label htmlFor="confirmPassword" className="form-component__label">
          Confirm Password
        </label>
        <input
          id="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleInputChange('confirmPassword')}
          className="form-component__input"
          disabled={loading}
        />
        {validationErrors.confirmPassword && (
          <span className="form-component__field-error">
            {validationErrors.confirmPassword}
          </span>
        )}
      </div>
      
      <button
        type="submit"
        className="form-component__submit"
        disabled={loading}
      >
        {loading ? 'Submitting...' : 'Submit'}
      </button>
    </form>
  );
}
```

## TypeScript Utilities

### API Client Template
```typescript
interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

interface ApiError {
  message: string;
  status: number;
  code?: string;
}

class ApiClient {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;

  constructor(baseUrl: string, defaultHeaders: Record<string, string> = {}) {
    this.baseUrl = baseUrl;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...defaultHeaders
    };
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${endpoint}`;
    const config: RequestInit = {
      headers: {
        ...this.defaultHeaders,
        ...options.headers
      },
      ...options
    };

    try {
      const response = await fetch(url, config);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || `HTTP ${response.status}`);
      }

      return data;
    } catch (error) {
      if (error instanceof Error) {
        throw new ApiError(error.message, 500);
      }
      throw new ApiError('Unknown error occurred', 500);
    }
  }

  async get<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T>(endpoint: string, data: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  async put<T>(endpoint: string, data: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }

  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}

export { ApiClient, ApiResponse, ApiError };
```

### Validation Utilities
```typescript
interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

class Validator {
  static required(value: any, fieldName: string): ValidationResult {
    if (value === null || value === undefined || value === '') {
      return {
        isValid: false,
        errors: [`${fieldName} is required`]
      };
    }
    return { isValid: true, errors: [] };
  }

  static email(value: string, fieldName: string = 'Email'): ValidationResult {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return {
        isValid: false,
        errors: [`${fieldName} must be a valid email address`]
      };
    }
    return { isValid: true, errors: [] };
  }

  static minLength(value: string, minLength: number, fieldName: string): ValidationResult {
    if (value.length < minLength) {
      return {
        isValid: false,
        errors: [`${fieldName} must be at least ${minLength} characters long`]
      };
    }
    return { isValid: true, errors: [] };
  }

  static maxLength(value: string, maxLength: number, fieldName: string): ValidationResult {
    if (value.length > maxLength) {
      return {
        isValid: false,
        errors: [`${fieldName} must be no more than ${maxLength} characters long`]
      };
    }
    return { isValid: true, errors: [] };
  }

  static pattern(value: string, pattern: RegExp, fieldName: string, message?: string): ValidationResult {
    if (!pattern.test(value)) {
      return {
        isValid: false,
        errors: [message || `${fieldName} format is invalid`]
      };
    }
    return { isValid: true, errors: [] };
  }

  static validateAll(validations: ValidationResult[]): ValidationResult {
    const allErrors = validations.flatMap(v => v.errors);
    return {
      isValid: allErrors.length === 0,
      errors: allErrors
    };
  }
}

export { Validator, ValidationResult };
```

### Error Handling Utilities
```typescript
class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(message: string, statusCode: number = 500, isOperational: boolean = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404);
  }
}

class UnauthorizedError extends AppError {
  constructor(message: string = 'Unauthorized') {
    super(message, 401);
  }
}

class ForbiddenError extends AppError {
  constructor(message: string = 'Forbidden') {
    super(message, 403);
  }
}

function handleError(error: Error): AppError {
  if (error instanceof AppError) {
    return error;
  }

  // Log unexpected errors
  console.error('Unexpected error:', error);

  return new AppError('Internal server error', 500, false);
}

export {
  AppError,
  ValidationError,
  NotFoundError,
  UnauthorizedError,
  ForbiddenError,
  handleError
};
```

## API Patterns

### Express.js Route Template
```typescript
import { Request, Response, NextFunction } from 'express';
import { ApiResponse, AppError } from '../utils';

interface RequestWithUser extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

export async function getResource(
  req: RequestWithUser,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const { id } = req.params;
    
    // Validate input
    if (!id) {
      throw new AppError('Resource ID is required', 400);
    }

    // Business logic here
    const resource = await getResourceById(id);
    
    if (!resource) {
      throw new AppError('Resource not found', 404);
    }

    // Check permissions
    if (req.user && req.user.id !== resource.ownerId) {
      throw new AppError('Access denied', 403);
    }

    const response: ApiResponse<typeof resource> = {
      data: resource,
      success: true,
      message: 'Resource retrieved successfully'
    };

    res.status(200).json(response);
  } catch (error) {
    next(error);
  }
}

export async function createResource(
  req: RequestWithUser,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const resourceData = req.body;
    
    // Validate input
    const validation = validateResourceData(resourceData);
    if (!validation.isValid) {
      throw new AppError(validation.errors.join(', '), 400);
    }

    // Business logic here
    const newResource = await createResourceInDatabase({
      ...resourceData,
      ownerId: req.user?.id
    });

    const response: ApiResponse<typeof newResource> = {
      data: newResource,
      success: true,
      message: 'Resource created successfully'
    };

    res.status(201).json(response);
  } catch (error) {
    next(error);
  }
}
```

### Middleware Template
```typescript
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils';

export function authMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      throw new AppError('Authentication token required', 401);
    }

    // Verify token logic here
    const user = verifyToken(token);
    
    if (!user) {
      throw new AppError('Invalid authentication token', 401);
    }

    // Attach user to request
    (req as any).user = user;
    
    next();
  } catch (error) {
    next(error);
  }
}

export function validateRequest(schema: any) {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      const { error } = schema.validate(req.body);
      
      if (error) {
        throw new AppError(error.details[0].message, 400);
      }
      
      next();
    } catch (error) {
      next(error);
    }
  };
}

export function errorHandler(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const appError = error instanceof AppError ? error : new AppError('Internal server error', 500);
  
  res.status(appError.statusCode).json({
    success: false,
    message: appError.message,
    ...(process.env.NODE_ENV === 'development' && { stack: appError.stack })
  });
}
```

## Testing Patterns

### Unit Test Template
```typescript
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { ComponentName } from './ComponentName';

// Mock dependencies
jest.mock('../utils/api-client', () => ({
  ApiClient: jest.fn().mockImplementation(() => ({
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn()
  }))
}));

describe('ComponentName', () => {
  let component: ComponentName;
  let mockApiClient: jest.Mocked<any>;

  beforeEach(() => {
    // Setup mocks
    mockApiClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn(),
      delete: jest.fn()
    };
    
    // Initialize component
    component = new ComponentName(mockApiClient);
  });

  describe('methodName', () => {
    it('should return expected result when conditions are met', async () => {
      // Arrange
      const input = 'test-input';
      const expectedOutput = { id: 1, name: 'test' };
      mockApiClient.get.mockResolvedValue({ data: expectedOutput });

      // Act
      const result = await component.methodName(input);

      // Assert
      expect(result).toEqual(expectedOutput);
      expect(mockApiClient.get).toHaveBeenCalledWith(`/endpoint/${input}`);
    });

    it('should throw error when API call fails', async () => {
      // Arrange
      const input = 'test-input';
      const error = new Error('API Error');
      mockApiClient.get.mockRejectedValue(error);

      // Act & Assert
      await expect(component.methodName(input)).rejects.toThrow('API Error');
    });

    it('should handle edge cases correctly', () => {
      // Arrange
      const edgeCaseInput = '';

      // Act & Assert
      expect(() => component.methodName(edgeCaseInput)).toThrow('Input is required');
    });
  });
});
```

### Integration Test Template
```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import request from 'supertest';
import { app } from '../app';
import { setupTestDatabase, cleanupTestDatabase } from '../test-utils';

describe('API Integration Tests', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  beforeEach(async () => {
    // Clean up data between tests
    await cleanupTestData();
  });

  describe('GET /api/resources', () => {
    it('should return list of resources', async () => {
      // Arrange
      await createTestResource({ name: 'Test Resource' });

      // Act
      const response = await request(app)
        .get('/api/resources')
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(1);
      expect(response.body.data[0].name).toBe('Test Resource');
    });

    it('should return empty array when no resources exist', async () => {
      // Act
      const response = await request(app)
        .get('/api/resources')
        .expect(200);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(0);
    });
  });

  describe('POST /api/resources', () => {
    it('should create new resource with valid data', async () => {
      // Arrange
      const resourceData = {
        name: 'New Resource',
        description: 'Test description'
      };

      // Act
      const response = await request(app)
        .post('/api/resources')
        .send(resourceData)
        .expect(201);

      // Assert
      expect(response.body.success).toBe(true);
      expect(response.body.data.name).toBe(resourceData.name);
      expect(response.body.data.description).toBe(resourceData.description);
    });

    it('should return validation error for invalid data', async () => {
      // Arrange
      const invalidData = {
        name: '', // Invalid: empty name
        description: 'Test description'
      };

      // Act
      const response = await request(app)
        .post('/api/resources')
        .send(invalidData)
        .expect(400);

      // Assert
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('name is required');
    });
  });
});
```

## Configuration Templates

### Environment Configuration
```typescript
interface Config {
  port: number;
  nodeEnv: string;
  database: {
    url: string;
    maxConnections: number;
  };
  redis: {
    url: string;
    ttl: number;
  };
  jwt: {
    secret: string;
    expiresIn: string;
  };
  api: {
    baseUrl: string;
    timeout: number;
  };
}

function loadConfig(): Config {
  const requiredEnvVars = [
    'DATABASE_URL',
    'REDIS_URL',
    'JWT_SECRET',
    'API_BASE_URL'
  ];

  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }

  return {
    port: parseInt(process.env.PORT || '3000', 10),
    nodeEnv: process.env.NODE_ENV || 'development',
    database: {
      url: process.env.DATABASE_URL!,
      maxConnections: parseInt(process.env.DB_MAX_CONNECTIONS || '10', 10)
    },
    redis: {
      url: process.env.REDIS_URL!,
      ttl: parseInt(process.env.REDIS_TTL || '3600', 10)
    },
    jwt: {
      secret: process.env.JWT_SECRET!,
      expiresIn: process.env.JWT_EXPIRES_IN || '24h'
    },
    api: {
      baseUrl: process.env.API_BASE_URL!,
      timeout: parseInt(process.env.API_TIMEOUT || '5000', 10)
    }
  };
}

export const config = loadConfig();
```

### Database Configuration
```typescript
import { Pool, PoolConfig } from 'pg';
import { config } from './config';

const dbConfig: PoolConfig = {
  connectionString: config.database.url,
  max: config.database.maxConnections,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  ssl: config.nodeEnv === 'production' ? { rejectUnauthorized: false } : false
};

export const pool = new Pool(dbConfig);

// Test connection
pool.on('connect', () => {
  console.log('Database connected successfully');
});

pool.on('error', (err) => {
  console.error('Database connection error:', err);
});

export async function testConnection(): Promise<boolean> {
  try {
    const client = await pool.connect();
    await client.query('SELECT NOW()');
    client.release();
    return true;
  } catch (error) {
    console.error('Database connection test failed:', error);
    return false;
  }
}
```

## Build Scripts

### Package.json Scripts
```json
{
  "scripts": {
    "dev": "concurrently \"npm run dev:frontend\" \"npm run dev:backend\"",
    "dev:frontend": "cd frontend && npm run dev",
    "dev:backend": "cd backend && npm run dev",
    "build": "npm run build:frontend && npm run build:backend",
    "build:frontend": "cd frontend && npm run build",
    "build:backend": "cd backend && npm run build",
    "test": "npm run test:frontend && npm run test:backend",
    "test:frontend": "cd frontend && npm test",
    "test:backend": "cd backend && npm test",
    "test:coverage": "npm run test:coverage:frontend && npm run test:coverage:backend",
    "test:coverage:frontend": "cd frontend && npm run test:coverage",
    "test:coverage:backend": "cd backend && npm run test:coverage",
    "lint": "npm run lint:frontend && npm run lint:backend",
    "lint:frontend": "cd frontend && npm run lint",
    "lint:backend": "cd backend && npm run lint",
    "lint:fix": "npm run lint:fix:frontend && npm run lint:fix:backend",
    "lint:fix:frontend": "cd frontend && npm run lint:fix",
    "lint:fix:backend": "cd backend && npm run lint:fix",
    "typecheck": "npm run typecheck:frontend && npm run typecheck:backend",
    "typecheck:frontend": "cd frontend && npm run typecheck",
    "typecheck:backend": "cd backend && npm run typecheck",
    "clean": "npm run clean:frontend && npm run clean:backend",
    "clean:frontend": "cd frontend && rm -rf dist node_modules",
    "clean:backend": "cd backend && rm -rf dist node_modules",
    "install:all": "npm install && npm run install:frontend && npm run install:backend",
    "install:frontend": "cd frontend && npm install",
    "install:backend": "cd backend && npm install",
    "verify": "npm run lint && npm run typecheck && npm run test",
    "prepare": "husky install",
    "postinstall": "npm run prepare"
  }
}
```

### Build Script Template
```bash
#!/bin/bash

# Build script template
set -e

echo "üöÄ Starting build process..."

# Check if required tools are installed
check_tool() {
    if ! command -v $1 &> /dev/null; then
        echo "‚ùå $1 is not installed. Please install it first."
        exit 1
    fi
}

echo "üîç Checking required tools..."
check_tool "node"
check_tool "npm"

# Get Node.js version
NODE_VERSION=$(node --version)
echo "üì¶ Using Node.js version: $NODE_VERSION"

# Install dependencies
echo "üì• Installing dependencies..."
npm run install:all

# Run linting
echo "üîç Running linting..."
npm run lint

# Run type checking
echo "üîß Running type checking..."
npm run typecheck

# Run tests
echo "üß™ Running tests..."
npm run test

# Build project
echo "üèóÔ∏è Building project..."
npm run build

echo "‚úÖ Build completed successfully!"
```

## Documentation Templates

### README Template
```markdown
# Project Name

Brief description of the project and its purpose.

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [API Reference](#api-reference)
- [Contributing](#contributing)
- [License](#license)

## Installation

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm
- [Other prerequisites]

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/username/project-name.git
   cd project-name
   ```

2. Install dependencies:
   ```bash
   npm install
   # or
   yarn install
   # or
   pnpm install
   ```

3. Set up environment variables:
   ```bash
   cp .env.example .env.local
   # Edit .env.local with your configuration
   ```

4. Run the development server:
   ```bash
   npm run dev
   ```

## Usage

### Basic Usage

```typescript
import { ComponentName } from './components/ComponentName';

function App() {
  return (
    <div>
      <ComponentName title="Hello World" />
    </div>
  );
}
```

### Advanced Usage

[Add more complex examples here]

## API Reference

### Components

#### ComponentName

A reusable component for [purpose].

**Props:**
- `title` (string, required): The title to display
- `onAction` (function, optional): Callback function when action is triggered
- `children` (ReactNode, optional): Child elements to render

**Example:**
```typescript
<ComponentName 
  title="My Title" 
  onAction={() => console.log('Action triggered')}
>
  <p>Child content</p>
</ComponentName>
```

### Hooks

#### useHookName

A custom hook for [purpose].

**Parameters:**
- `options` (object, optional): Configuration options
  - `initialValue` (string, optional): Initial value (default: '')
  - `onSuccess` (function, optional): Success callback
  - `onError` (function, optional): Error callback

**Returns:**
- `data` (any): The fetched data
- `loading` (boolean): Loading state
- `error` (Error | null): Error state
- `refetch` (function): Function to refetch data

**Example:**
```typescript
const { data, loading, error, refetch } = useHookName({
  initialValue: 'test',
  onSuccess: (data) => console.log('Success:', data),
  onError: (error) => console.error('Error:', error)
});
```

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add amazing feature'`
4. Push to the branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

### Development Guidelines

- Follow the coding conventions outlined in [conventions.md](.cursor/library/conventions.md)
- Write tests for new features
- Update documentation as needed
- Ensure all tests pass before submitting a PR

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
```

---

## Summary

These conventions and code snippets provide a solid foundation for any project type while maintaining consistency and best practices. Remember:

1. **Start Simple**: Begin with basic conventions and add complexity as needed
2. **Be Consistent**: Apply conventions uniformly across the entire project
3. **Document Changes**: Update this document when conventions evolve
4. **Team Alignment**: Ensure all team members understand and follow these conventions
5. **Tool Integration**: Use tools like ESLint, Prettier, and Husky to enforce conventions automatically

For project-specific conventions, create additional documentation in the `docs/` directory and reference it from this file.