#!/usr/bin/env node

/**
 * verify-all - Comprehensive verification script (Scaffold-Ready)
 * Runs lint, types, tests, and build checks across the project
 * Usage: scripts/verify-all [--fix] [--verbose] [--parallel]
 * 
 * This script is scaffold-ready and will work with any project type:
 * - Detects project type automatically (Next.js, React, Node.js, etc.)
 * - Adapts verification steps based on available package.json scripts
 * - Gracefully handles missing dependencies or configurations
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration
const config = {
  parallel: process.argv.includes('--parallel'),
  fix: process.argv.includes('--fix'),
  verbose: process.argv.includes('--verbose'),
  artifactsDir: path.join(__dirname, '..', 'artifacts'),
};

// Colors for output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function ensureArtifactsDir() {
  if (!fs.existsSync(config.artifactsDir)) {
    fs.mkdirSync(config.artifactsDir, { recursive: true });
    log(`Created artifacts directory: ${config.artifactsDir}`, 'blue');
  }
}

function detectProjectType() {
  const packageJsonPath = path.join(__dirname, '..', 'package.json');
  
  if (!fs.existsSync(packageJsonPath)) {
    return { type: 'unknown', hasPackageJson: false };
  }
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const scripts = packageJson.scripts || {};
    const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
    
    // Detect project type based on dependencies and scripts
    if (dependencies.next) {
      return { type: 'nextjs', hasPackageJson: true, scripts, dependencies };
    } else if (dependencies.react) {
      return { type: 'react', hasPackageJson: true, scripts, dependencies };
    } else if (dependencies.express || dependencies.fastify || dependencies.koa) {
      return { type: 'nodejs', hasPackageJson: true, scripts, dependencies };
    } else if (dependencies.vue) {
      return { type: 'vue', hasPackageJson: true, scripts, dependencies };
    } else if (dependencies.svelte) {
      return { type: 'svelte', hasPackageJson: true, scripts, dependencies };
    } else {
      return { type: 'generic', hasPackageJson: true, scripts, dependencies };
    }
  } catch (error) {
    return { type: 'unknown', hasPackageJson: true, error: error.message };
  }
}

function getAvailableScripts(projectInfo) {
  const availableScripts = [];
  const { scripts, dependencies } = projectInfo;
  
  // Check for common scripts and adapt based on what's available
  if (scripts.lint) {
    availableScripts.push({
      command: `npm run lint${config.fix ? ' --fix' : ''}`,
      description: 'Linting',
      required: false
    });
  }
  
  if (scripts.typecheck || scripts.tsc) {
    availableScripts.push({
      command: 'npm run typecheck || npm run tsc',
      description: 'Type checking',
      required: false
    });
  }
  
  if (scripts.test) {
    availableScripts.push({
      command: 'npm test',
      description: 'Unit tests',
      required: false
    });
  }
  
  if (scripts.build) {
    availableScripts.push({
      command: 'npm run build',
      description: 'Build',
      required: false
    });
  }
  
  // Add project-specific scripts
  if (projectInfo.type === 'nextjs') {
    if (scripts['frontend:build']) {
      availableScripts.push({
        command: 'npm run frontend:build',
        description: 'Frontend build',
        required: false
      });
    }
  }
  
  // Always add dependency audit if package.json exists
  if (projectInfo.hasPackageJson) {
    availableScripts.push({
      command: 'npm audit --audit-level=moderate',
      description: 'Dependency audit',
      required: false
    });
  }
  
  return availableScripts;
}

function runCommand(command, description, options = {}) {
  const startTime = Date.now();
  log(`\nðŸ” ${description}...`, 'cyan');
  
  try {
    const result = execSync(command, {
      stdio: config.verbose ? 'inherit' : 'pipe',
      cwd: process.cwd(),
      encoding: 'utf8',
      ...options
    });
    
    const duration = Date.now() - startTime;
    log(`âœ… ${description} completed (${duration}ms)`, 'green');
    
    // Save output to artifacts if not verbose
    if (!config.verbose && result) {
      const artifactFile = path.join(config.artifactsDir, `${description.toLowerCase().replace(/\s+/g, '-')}.log`);
      fs.writeFileSync(artifactFile, result);
    }
    
    return { success: true, output: result, duration };
  } catch (error) {
    const duration = Date.now() - startTime;
    log(`âŒ ${description} failed (${duration}ms)`, 'red');
    
    // Save error output to artifacts
    const errorFile = path.join(config.artifactsDir, `${description.toLowerCase().replace(/\s+/g, '-')}-error.log`);
    fs.writeFileSync(errorFile, error.message + '\n' + (error.stdout || '') + '\n' + (error.stderr || ''));
    
    if (config.verbose) {
      console.error(error.message);
    }
    
    return { success: false, error: error.message, duration };
  }
}

async function runParallel(tasks) {
  log('\nðŸš€ Running tasks in parallel...', 'magenta');
  
  const promises = tasks.map(({ command, description, options }) => 
    new Promise((resolve) => {
      const result = runCommand(command, description, options);
      resolve({ description, ...result });
    })
  );
  
  const results = await Promise.all(promises);
  return results;
}

function runSequential(tasks) {
  log('\nðŸ“‹ Running tasks sequentially...', 'magenta');
  
  const results = [];
  for (const { command, description, options } of tasks) {
    const result = runCommand(command, description, options);
    results.push({ description, ...result });
    
    // Stop on first failure unless --continue flag is present
    if (!result.success && !process.argv.includes('--continue')) {
      break;
    }
  }
  
  return results;
}

function generateSummary(results) {
  const totalDuration = results.reduce((sum, r) => sum + (r.duration || 0), 0);
  const successful = results.filter(r => r.success).length;
  const failed = results.length - successful;
  
  log('\nðŸ“Š VERIFICATION SUMMARY', 'magenta');
  log('='.repeat(50), 'magenta');
  log(`Total tasks: ${results.length}`, 'blue');
  log(`Successful: ${successful}`, successful === results.length ? 'green' : 'yellow');
  log(`Failed: ${failed}`, failed > 0 ? 'red' : 'green');
  log(`Total time: ${totalDuration}ms`, 'blue');
  
  if (failed > 0) {
    log('\nâŒ Failed tasks:', 'red');
    results.filter(r => !r.success).forEach(r => {
      log(`  - ${r.description}`, 'red');
    });
    
    log(`\nðŸ’¡ Check artifacts directory for detailed logs: ${config.artifactsDir}`, 'yellow');
  } else {
    log('\nðŸŽ‰ All verifications passed!', 'green');
  }
  
  return failed === 0;
}

async function main() {
  log('ðŸ”§ Project Verification Suite (Scaffold-Ready)', 'cyan');
  log('==============================================', 'cyan');
  
  ensureArtifactsDir();
  
  // Detect project type and available scripts
  const projectInfo = detectProjectType();
  log(`\nðŸ“¦ Detected project type: ${projectInfo.type}`, 'blue');
  
  if (!projectInfo.hasPackageJson) {
    log('âš ï¸  No package.json found. This is a scaffold template.', 'yellow');
    log('ðŸ’¡ To use this script, initialize your project with: npm init', 'yellow');
    process.exit(0);
  }
  
  // Get available verification tasks
  const tasks = getAvailableScripts(projectInfo);
  
  if (tasks.length === 0) {
    log('âš ï¸  No verification scripts found in package.json', 'yellow');
    log('ðŸ’¡ Add scripts like "lint", "test", "build" to your package.json', 'yellow');
    process.exit(0);
  }
  
  log(`\nðŸ” Found ${tasks.length} verification tasks:`, 'blue');
  tasks.forEach(task => {
    log(`  - ${task.description}`, 'cyan');
  });
  
  // Run tasks
  const results = config.parallel 
    ? await runParallel(tasks)
    : runSequential(tasks);
  
  // Generate summary
  const allPassed = generateSummary(results);
  
  // Exit with appropriate code
  process.exit(allPassed ? 0 : 1);
}

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  log(`\nðŸ’¥ Uncaught exception: ${error.message}`, 'red');
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  log(`\nðŸ’¥ Unhandled rejection: ${reason}`, 'red');
  process.exit(1);
});

// Run main function
if (require.main === module) {
  main().catch(error => {
    log(`\nðŸ’¥ Fatal error: ${error.message}`, 'red');
    process.exit(1);
  });
}

module.exports = { runCommand, generateSummary, detectProjectType };
