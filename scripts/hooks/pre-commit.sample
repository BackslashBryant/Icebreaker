#!/usr/bin/env bash
# Optional path-scope guard. Install with:
#   cp scripts/hooks/pre-commit.sample .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit

# Function to detect repo mode (template or app)
detect_repo_mode() {
  local repo_mode_file=".repo-mode"
  if [ -f "$repo_mode_file" ]; then
    local mode=$(cat "$repo_mode_file" 2>/dev/null | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')
    if [ "$mode" = "template" ] || [ "$mode" = "app" ]; then
      echo "$mode"
      return
    fi
  fi

  # Fallback: check package.json for "template" indicators
  if [ -f "package.json" ]; then
    local name=$(grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' package.json 2>/dev/null | grep -i template)
    local desc=$(grep -o '"description"[[:space:]]*:[[:space:]]*"[^"]*"' package.json 2>/dev/null | grep -i template)
    if [ -n "$name" ] || [ -n "$desc" ]; then
      echo "template"
      return
    fi
  fi

  # Default to template mode
  echo "template"
}

# Check if Cursor files are being committed in app mode
check_cursor_files() {
  local mode=$(detect_repo_mode)

  # In template mode, allow all Cursor files
  if [ "$mode" = "template" ]; then
    return 0
  fi

  # In app mode, block .cursor/ files (except .cursorignore)
  if [ "$mode" = "app" ] && [ "$ALLOW_CURSOR_PUSH" != "1" ]; then
    local files=$(git diff --cached --name-only)
    local violations=0

    while IFS= read -r f; do
      # Block .cursor/ directory files except .cursorignore
      if [[ "$f" =~ ^\.cursor/ ]] && [ "$f" != ".cursorignore" ]; then
        echo "BLOCK: Cannot commit Cursor logic files in app mode: $f"
        echo "       Repo is in app mode. Cursor files (.cursor/) are not allowed."
        echo "       Exceptions: .cursorignore is allowed (app-specific config)"
        echo ""
        echo "       To override (for template updates only): ALLOW_CURSOR_PUSH=1 git commit"
        violations=1
      fi
    done <<< "$files"

    if [ $violations -ne 0 ]; then
      return 1
    fi
  fi

  return 0
}

# Run Cursor file check first
if ! check_cursor_files; then
  exit 1
fi

# Prevent non-app logic commits outside main
if ! node tools/check-nonapp-branch.mjs >/dev/null 2>&1; then
  node tools/check-nonapp-branch.mjs
  exit 1
fi

# Check branch naming format (warn but don't block for now)
branch="$(git rev-parse --abbrev-ref HEAD)"
if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
  if ! [[ "$branch" =~ ^(agent/[^/]+/[0-9]+-[^/]+|feat/[0-9]+-[^/]+)$ ]]; then
    echo "[pre-commit] WARNING: Branch '$branch' does not match required format: agent/<agent>/<issue>-<slug> or feat/<issue>-<slug>"
    echo "[pre-commit] Example: agent/vector/1-onboarding-flow"
    echo "[pre-commit] Continuing anyway, but please use proper branch naming next time."
  fi
fi

echo "[pre-commit] Running sanity checks..."
if [ "$SKIP_STATUS" != "1" ]; then
  if ! npm run status -- --ci >/dev/null; then
    echo "[pre-commit] Workspace status failed. Fix issues or run Allow overrides intentionally."
    exit 1
  fi
else
  echo "[pre-commit] Skipping status checks (SKIP_STATUS=1)."
fi
echo "[pre-commit] Done."

# Check for placeholder dates in staged files
echo "[pre-commit] Checking for placeholder dates..."
if ! node tools/check-dates.mjs --staged >/dev/null 2>&1; then
  echo ""
  echo "BLOCK: Placeholder dates detected in staged files."
  echo ""
  echo "Options:"
  echo "  1. Auto-fix: Run 'npm run fix:dates' to automatically fix placeholder dates"
  echo "  2. Manual fix: Use Time MCP to get accurate dates (see .cursor/rules/04-integrations.mdc)"
  echo ""
  node tools/check-dates.mjs --staged
  exit 1
fi
echo "[pre-commit] Date validation passed."

# Validate workflow guardrails (matrix/config alignment, browser deps)
echo "[pre-commit] Validating workflow guardrails..."
if command -v node >/dev/null 2>&1; then
  # Check if workflow or playwright config files are staged
  staged_files=$(git diff --cached --name-only)
  workflow_changed=$(echo "$staged_files" | grep -E '\.github/workflows/.*\.yml|tests/playwright\.config\.(ts|smoke\.ts)' || true)
  
  if [ -n "$workflow_changed" ]; then
    if [ -f "tools/validate-matrix-config.mjs" ]; then
      if ! node tools/validate-matrix-config.mjs >/dev/null 2>&1; then
        echo ""
        echo "BLOCK: Matrix/config validation failed."
        echo ""
        node tools/validate-matrix-config.mjs
        exit 1
      fi
    fi
    
    if [ -f "tools/validate-browser-deps.mjs" ]; then
      if ! node tools/validate-browser-deps.mjs >/dev/null 2>&1; then
        echo ""
        echo "BLOCK: Browser dependency validation failed."
        echo ""
        node tools/validate-browser-deps.mjs
        exit 1
      fi
    fi
    
    if [ -f "tools/validate-job-scopes.mjs" ]; then
      if ! node tools/validate-job-scopes.mjs >/dev/null 2>&1; then
        echo ""
        echo "WARNING: Job scope validation failed."
        echo ""
        node tools/validate-job-scopes.mjs
        echo ""
        echo "Review job scopes and fix violations."
        read -p "Continue anyway? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
          exit 1
        fi
      fi
    fi
  fi
fi
echo "[pre-commit] Workflow guardrails validation passed."

# Run linting on staged files (fast check)
echo "[pre-commit] Running linter on staged files..."
if command -v npm >/dev/null 2>&1; then
  # Check if eslint is available and run on staged files
  if npm list eslint >/dev/null 2>&1 || [ -f "node_modules/.bin/eslint" ]; then
    staged_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(js|jsx|ts|tsx|mjs)$' || true)
    if [ -n "$staged_files" ]; then
      if ! npx eslint --max-warnings=0 $staged_files 2>/dev/null; then
        echo "Linting errors found in staged files."
        echo "Run 'npm run guard:lint' to see all issues, or 'npm run guard:lint -- --fix' to auto-fix."
        exit 1
      fi
    fi
  fi
fi

# Check for potential secrets (API keys, tokens, passwords)
echo "[pre-commit] Checking for potential secrets..."
staged_content=$(git diff --cached)
if echo "$staged_content" | grep -qiE '(api[_-]?key|secret[_-]?key|password|token|auth[_-]?token)\s*[:=]\s*["\047]?[a-zA-Z0-9]{20,}'; then
  echo "WARNING: Potential secret detected in staged files!"
  echo "Review the following patterns:"
  echo "$staged_content" | grep -iE '(api[_-]?key|secret[_-]?key|password|token|auth[_-]?token)\s*[:=]' || true
  echo ""
  echo "If this is a false positive, you can bypass with: git commit --no-verify"
  echo "Otherwise, remove the secret and use environment variables instead."
  read -p "Continue anyway? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
  fi
fi

# Check file sizes (prevent accidentally committing large files)
echo "[pre-commit] Checking file sizes..."
MAX_SIZE=524288  # 512KB
large_files=""
while IFS= read -r file; do
  if [ -f "$file" ]; then
    if [ "$(uname)" = "Darwin" ]; then
      size=$(stat -f%z "$file" 2>/dev/null || echo 0)
    else
      size=$(stat -c%s "$file" 2>/dev/null || echo 0)
    fi
    if [ "$size" -gt "$MAX_SIZE" ]; then
      large_files="${large_files}${file} ($(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size} bytes"))\n"
    fi
  fi
done <<< "$(git diff --cached --name-only)"

if [ -n "$large_files" ]; then
  echo "WARNING: Large files detected (>512KB):"
  echo -e "$large_files"
  echo "Consider using Git LFS for large files or removing unnecessary files."
  read -p "Continue anyway? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
  fi
fi

# Detect merge conflict markers (prevent committing conflicts)
echo "[pre-commit] Checking for merge conflict markers..."
staged_content=$(git diff --cached)
if echo "$staged_content" | grep -qE '^[<>=]{7}|^<<<<<<<|^=======|^>>>>>>>'; then
  echo "ERROR: Merge conflict markers detected in staged files!"
  echo "Resolve conflicts before committing."
  echo ""
  echo "$staged_content" | grep -nE '^[<>=]{7}|^<<<<<<<|^=======|^>>>>>>>' | head -10
  exit 1
fi

# Check for accidental .env commits (security)
echo "[pre-commit] Checking for .env files..."
env_files=$(git diff --cached --name-only | grep -E '\.env$|\.env\.(local|development|production|test)$' || true)
if [ -n "$env_files" ]; then
  echo "WARNING: .env files detected in staged files:"
  echo "$env_files"
  echo ""
  echo "These files may contain secrets. Use .env.example for templates."
  read -p "Continue anyway? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
  fi
fi

# Validate lock file consistency (prevent dependency issues)
if [ "$SKIP_LOCK_CHECK" != "1" ]; then
  echo "[pre-commit] Checking lock file consistency..."
  if git diff --cached --name-only | grep -q 'package.json'; then
    if [ -f "package-lock.json" ] && ! git diff --cached --name-only | grep -q 'package-lock.json'; then
      echo "WARNING: package.json changed but package-lock.json not staged."
      echo "Run 'npm install' to update lock file, then stage it."
      read -p "Continue anyway? (y/N) " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
      fi
    fi
  fi
else
  echo "[pre-commit] Skipping lock file check (SKIP_LOCK_CHECK=1)."
fi

# Check for binary files in text-only directories
echo "[pre-commit] Checking for binary files in text directories..."
text_dirs='^(docs|scripts|tools|\.cursor/rules)/'
binary_extensions='\.(png|jpg|jpeg|gif|ico|pdf|zip|tar|gz|exe|dll|so|dylib)$'
staged_files=$(git diff --cached --name-only)
while IFS= read -r file; do
  if [[ "$file" =~ $text_dirs ]] && [[ "$file" =~ $binary_extensions ]]; then
    echo "WARNING: Binary file in text directory: $file"
    echo "Consider using Git LFS or moving to assets/ directory."
  fi
done <<< "$staged_files"

# Validate YAML/JSON files (prevent CI failures)
echo "[pre-commit] Validating YAML/JSON files..."
yaml_files=$(git diff --cached --name-only | grep -E '\.(yml|yaml)$' || true)
json_files=$(git diff --cached --name-only | grep -E '\.json$' || true)

if [ -n "$yaml_files" ]; then
  for file in $yaml_files; do
    if command -v yamllint >/dev/null 2>&1; then
      if ! yamllint "$file" >/dev/null 2>&1; then
        echo "YAML validation error in $file"
        yamllint "$file" || true
        exit 1
      fi
    elif command -v python3 >/dev/null 2>&1; then
      if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
        echo "YAML syntax error in $file"
        exit 1
      fi
    fi
  done
fi

if [ -n "$json_files" ]; then
  for file in $json_files; do
    if command -v node >/dev/null 2>&1; then
      if ! node -e "JSON.parse(require('fs').readFileSync('$file', 'utf8'))" 2>/dev/null; then
        echo "JSON syntax error in $file"
        exit 1
      fi
    fi
  done
fi

# Agent path-scope guard (advisory only - team-friendly)
# Only enforce if AGENT_SCOPE_ENFORCE=1 is set (for agent-only workflows)
# Otherwise, just warn about potential scope mismatches
branch="$(git rev-parse --abbrev-ref HEAD)"
if [[ "$branch" =~ ^agent/[^/]+/ ]]; then
  case "$branch" in
    agent/forge/*)    expected='^(api|server|db|migrations)/' ;;
    agent/link/*)     expected='^(app|pages|components|styles)/' ;;
    agent/glide/*)    expected='^(app/|pwa/|public/|service-worker)' ;;
    agent/apex/*)     expected='^android/' ;;
    agent/cider/*)    expected='^ios/' ;;
    agent/pixel/*)    expected='^tests/|^jest|^vitest' ;;
    agent/muse/*)     expected='^(docs/|README\.md|CHANGELOG\.md)' ;;
    agent/nexus/*)    expected='^(\.github/|\.ci/|Dockerfile|vercel|deploy)' ;;
    agent/sentinel/*) expected='^docs/security/' ;;
    agent/scout/*)    expected='^docs/research\.md$' ;;
    *)                expected='' ;;
  esac
  
  if [ -n "$expected" ]; then
    files=$(git diff --cached --name-only)
    violations=0
    out_of_scope=""
    while IFS= read -r f; do
      if [ -n "$f" ] && ! [[ "$f" =~ $expected ]]; then
        out_of_scope="${out_of_scope}  - $f\n"
        violations=1
      fi
    done <<< "$files"
    
    if [ $violations -ne 0 ]; then
      if [ "$AGENT_SCOPE_ENFORCE" = "1" ]; then
        # Strict mode: block commits
        echo "BLOCK: $branch cannot modify files outside agent scope:"
        echo -e "$out_of_scope"
        echo "Tip: Use correct agent branch or set AGENT_SCOPE_ENFORCE=0 to allow (team mode)"
        exit 1
      else
        # Advisory mode: warn but allow (team-friendly)
        echo "[pre-commit] WARNING: $branch typically modifies files matching: $expected"
        echo "[pre-commit] Files outside expected scope:"
        echo -e "$out_of_scope"
        echo "[pre-commit] Continuing (team mode). Set AGENT_SCOPE_ENFORCE=1 for strict enforcement."
      fi
    fi
  fi
fi
